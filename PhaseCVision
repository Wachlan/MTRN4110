import cv2
import numpy as np
import matplotlib.pyplot as plt
import copy
%matplotlib inline


MAZE_FILE_NAME = "../Maze.png"
ROBOT_FILE_NAME = "../Robot.png"
MAP_FILE_NAME = "../MapFound.txt"



#Function to find the centre of a cornerstone, given a region of the image
def FindCentre(StartingRow, EndingRow, StartingCol, EndingCol, MazeCorners):
    Coordinates = []
    
    LowestRow = 0
    LowestCol = 0
    HighestRow = 0
    HighestCol = 0

    for row in range(StartingRow, EndingRow):
        for col in range(StartingCol, EndingCol):
            pixel = MazeCorners[row,col]
            if pixel[0] == 0 and pixel[1] == 0 and pixel[2] == 0:
                continue
            else:
                if LowestRow == 0:
                    LowestRow = row
                    #EndingRow = StartingRow + 20
                if LowestCol == 0:
                    LowestCol = col
                    #EndingCol = StartingCol + 20
                if row > HighestRow:
                    HighestRow = row
                if col > HighestCol:
                    HighestCol = col
                
    CentreRow = int((LowestRow + HighestRow)/2)
    CentreCol = int((LowestCol + HighestCol)/2)
    
    #print(LowestRow)
    ##print(HighestRow)
    #print(LowestCol)
    #print(HighestCol)
    #print( )
    
    Coordinates.append(CentreRow)
    Coordinates.append(CentreCol)
    
    return Coordinates


def FindRobotLocation(StartingRow, EndingRow, StartingCol, EndingCol, MazeWalls):
    PixelCounter = 0

    for row in range(StartingRow, EndingRow):
        for col in range(StartingCol, EndingCol):
            pixel = MazeWalls[row,col]
            if pixel[0] == 0 and pixel[1] == 0 and pixel[2] == 0:
                continue
            else:
                PixelCounter = PixelCounter + 1

    return PixelCounter

def FindHeading(markerCorners):
    RobotFrontX = int(markerCorners[0][0][0][0])
    RobotFrontY = int(markerCorners[0][0][0][1])

    RobotBackX = int(markerCorners[0][0][2][0])
    RobotBackY = int(markerCorners[0][0][2][1])
    
    #print(RobotFrontX) 
    #print(RobotBackX)
    
    #print(RobotFrontY)
    #print(RobotBackY)


    
    XDifference = abs(RobotFrontX - RobotBackX)
    YDifference = abs(RobotFrontY - RobotBackY)
    
    if XDifference > YDifference:
        if RobotFrontX < RobotBackX:
            heading = 'W'
        elif RobotFrontX > RobotBackX:
            heading = 'E'
    elif YDifference > XDifference:
        if RobotFrontY > RobotBackY:
            heading = 'S'
        elif RobotFrontY < RobotBackY:
            heading = 'N'
            
    return heading
    
##############################################################################################################################  

MazeImgBGR = cv2.imread(MAZE_FILE_NAME)                                       #read image
MazeImgRGB = cv2.cvtColor(MazeImgBGR, cv2.COLOR_BGR2RGB)                  #get RGB version
MazeImgShowCornerstones = copy.deepcopy(MazeImgRGB)
MazeImgHSV = cv2.cvtColor(MazeImgBGR, cv2.COLOR_BGR2HSV)                  #get HSV version
plt.imshow(MazeImgRGB)                                                    #show RGB version



#HSVLow = np.array([130,160,0])
#HSVHigh = np.array([229,255,255])


HSVLow = np.array([135,188,125])
HSVHigh = np.array([179,255,255])


mask = cv2.inRange(MazeImgHSV, HSVLow, HSVHigh)
MazeCorners = cv2.bitwise_and(MazeImgRGB, MazeImgRGB, mask=mask)


kernel = np.ones((3,3), np.uint8)

for i in range(3):
    MazeCorners = cv2.erode(MazeCorners, kernel, iterations = i)
    MazeCorners = cv2.dilate(MazeCorners, kernel, iterations = i)

plt.imshow(MazeCorners) 




#Find the centres of the cornerstones
TopLeft = FindCentre(0, 375, 0, 338, MazeCorners)
BottomLeft = FindCentre(375, 750, 0, 338, MazeCorners)
TopRight = FindCentre(0, 375, 1012, 1350, MazeCorners)
BottomRight = FindCentre(375, 750, 1012, 1350, MazeCorners)

print(TopLeft)
print(BottomLeft)
print(TopRight)
print(BottomRight)

cv2.rectangle(MazeImgShowCornerstones, (TopLeft[1]-10, TopLeft[0]-10), (TopLeft[1]+10, TopLeft[0]+10), (19,245,237), 2)
cv2.rectangle(MazeImgShowCornerstones, (BottomLeft[1]-10, BottomLeft[0]-10), (BottomLeft[1]+10, BottomLeft[0]+10), (19,245,237), 2)
cv2.rectangle(MazeImgShowCornerstones, (TopRight[1]-10, TopRight[0]-10), (TopRight[1]+10, TopRight[0]+10), (19,245,237), 2)
cv2.rectangle(MazeImgShowCornerstones, (BottomRight[1]-10, BottomRight[0]-10), (BottomRight[1]+10, BottomRight[0]+10), (19,245,237), 2)

plt.imshow(MazeImgShowCornerstones)



PerspectivePoints1 = np.float32([[TopLeft[1],TopLeft[0]],[BottomLeft[1],BottomLeft[0]],[TopRight[1],TopRight[0]],[BottomRight[1],BottomRight[0]]])
PerspectivePoints2 = np.float32([[0,0],[0,500],[900,0],[900,500]])

H = cv2.getPerspectiveTransform(PerspectivePoints1,PerspectivePoints2)

MazeImgTransformed = cv2.warpPerspective(MazeImgRGB, H, (900,500))
plt.imshow(MazeImgTransformed)






############################################################################################################################
#get internal walls
MazeImgBlueWalls = copy.deepcopy(MazeImgTransformed)
MazeWalls = copy.deepcopy(MazeImgTransformed)
MazeWallsHSV = cv2.cvtColor(MazeWalls, cv2.COLOR_RGB2HSV)                  #get HSV version

#plt.imshow(MazeWallsHSV)


#HSVLow = np.array([220,200,50])
#HSVHigh = np.array([240,230,200])

HSVLow = np.array([14,43,220])
HSVHigh = np.array([255,118,255])

mask = cv2.inRange(MazeWallsHSV, HSVLow, HSVHigh)
MazeWalls = cv2.bitwise_and(MazeWalls, MazeWalls, mask=mask)

#prepare kernel
#kernel = np.ones((3,3), np.uint8)


#make the walls blue
for row in range(500):
    for col in range(900):
        pixel = MazeWalls[row,col]
        if pixel[0] == 0 and pixel[1] == 0 and pixel[2] == 0:
            continue
        else:
            MazeImgBlueWalls[row,col] = [3,253,254]
    
   
#plt.imshow(MazeImgBlueWalls)



############################################################################################################################
#get robot location


RobotInMaze = copy.deepcopy(MazeImgTransformed)
RobotInMazeHSV = cv2.cvtColor(RobotInMaze, cv2.COLOR_RGB2HSV)                  #get HSV version


#HSVLow = np.array([36,0,34])
#HSVHigh = np.array([136,136,255])

HSVLow = np.array([36,0,126])
HSVHigh = np.array([136,125,220])

mask = cv2.inRange(RobotInMazeHSV, HSVLow, HSVHigh)
RobotInMaze = cv2.bitwise_and(RobotInMaze, RobotInMaze, mask=mask)

for i in range(5):
    MazeWalls = cv2.erode(MazeWalls, kernel, iterations = i)
    MazeWalls = cv2.dilate(MazeWalls, kernel, iterations = i)

plt.imshow(RobotInMaze)


Location = []

Location.append(FindRobotLocation(10, 90, 10, 90, RobotInMaze))    #top left
Location.append(FindRobotLocation(410, 490, 10, 90, RobotInMaze))   #bottom left
Location.append(FindRobotLocation(10, 90, 810, 890, RobotInMaze))   #top right
Location.append(FindRobotLocation(410, 490, 810, 890, RobotInMaze)) #bottom right

HighestPixelCnt = 0
RobotIndex = 0

    
for index in range(len(Location)):    # iterating over Location list
    if Location[index] > HighestPixelCnt:
        HighestPixelCnt = Location[index]
        RobotIndex = index
    else:
        continue


    
#find centre of robot
if RobotIndex == 0:
    RobotCentre = FindCentre(10, 90, 10, 90, RobotInMaze)
elif RobotIndex == 1:
    RobotCentre = FindCentre(410, 490, 10, 90, RobotInMaze)
elif RobotIndex == 2:
    RobotCentre = FindCentre(10, 90, 810, 890, RobotInMaze)
elif RobotIndex == 3:
    RobotCentre = FindCentre(410, 490, 810, 890, RobotInMaze)
    
print("robot centre is ")
print(RobotCentre)


    
#represent location of the robot with a purple circle
cv2.circle(MazeImgBlueWalls, (RobotCentre[0],RobotCentre[1]), 25, (155,1,171), 2)
  
    

#plt.imshow(MazeImgBlueWalls)


##########################################################################################################
#detect robot Heading

RobotImgBGR = cv2.imread(ROBOT_FILE_NAME)                                       #read image
RobotImgRGB = cv2.cvtColor(RobotImgBGR, cv2.COLOR_BGR2RGB)                  #get RGB version                                             #show RGB version



#load predefined dictionary
dictionary = cv2.aruco.Dictionary_get(cv2.aruco.DICT_6X6_250)

#initialise detector parameters
parameters = cv2.aruco.DetectorParameters_create()

#detect marker
markerCorners, markerIds, rejectedCandidates = cv2.aruco.detectMarkers(RobotImgRGB, dictionary, parameters=parameters)

cv2.aruco.drawDetectedMarkers(RobotImgRGB, markerCorners, markerIds)

#print(markerCorners)
#print(markerIds)



heading = FindHeading(markerCorners)
print(heading)

#print(int(markerCorners[0][0][2][0]))
#print(int(markerCorners[0][0][2][1]))

font = cv2.FONT_ITALIC

#cv2.putText(MazeImgBlueWalls,".",(RobotCentre[0],RobotCentre[1]), font, 1, (0,0,255), 3, cv2.LINE_AA)

if heading == 'N':
    cv2.arrowedLine(MazeImgBlueWalls, (RobotCentre[0],RobotCentre[1]+20), (RobotCentre[0],RobotCentre[1]-20), (155,1,171), (3), 8, 0, 0.5)
if heading == 'S':
    cv2.arrowedLine(MazeImgBlueWalls, (RobotCentre[0],RobotCentre[1]-20), (RobotCentre[0],RobotCentre[1]+20), (155,1,171), (3), 8, 0, 0.5)
if heading == 'E':
    cv2.arrowedLine(MazeImgBlueWalls, (RobotCentre[0]-20,RobotCentre[1]), (RobotCentre[0]+20,RobotCentre[1]), (155,1,171), (3), 8, 0, 0.5)
if heading == 'W':
    #cv2.arrowedLine(MazeImgBlueWalls, (RobotCentre[0],RobotCentre[1]+20), (RobotCentre[0],RobotCentre[1]-20), (155,1,171), (3), 8, 0, 0.5)
    cv2.putText(MazeImgBlueWalls,"<",(RobotCentre[0],RobotCentre[1]), font, 1, (0,0,255), 3, cv2.LINE_AA)

#plot the image
plt.imshow(MazeImgBlueWalls)




